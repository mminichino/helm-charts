apiVersion: app.redislabs.com/v1
kind: RedisEnterpriseCluster
metadata:
  name: {{ .Values.name }}
  namespace: {{ .Values.namespace | default .Release.Namespace }}
  labels:
    app: redis
spec:
  redisEnterpriseImageSpec:
    imagePullPolicy: IfNotPresent
    repository: redislabs/redis
    versionTag: {{ .Values.version }}
  redisEnterpriseNodeResources:
    limits:
      cpu: {{ .Values.node.cpu | quote }}
      memory: {{ .Values.node.memory }}
    requests:
      cpu: {{ .Values.node.cpu | quote }}
      memory: {{ .Values.node.memory }}
  nodes: {{ .Values.node.count }}
  persistentSpec:
    enabled: true
    storageClassName: "{{ .Values.storage.class }}"
    volumeSize: {{ .Values.node.disk }}
  username: {{ .Values.username }}
  redisUpgradePolicy: {{ .Values.upgradePolicy | quote }}
  {{- $tlsSecret := .Values.tls.secret | default "" }}
  {{- $syncerSecret := .Values.syncer.secret | default "" }}
  {{- $tlsCert := .Values.tls.certificate | default "" }}
  {{- $syncerCert := .Values.syncer.certificate | default "" }}
  {{- $tlsKey := .Values.tls.key | default "" }}
  {{- $syncerKey := .Values.syncer.key | default "" }}
  {{- if or (and $tlsCert $tlsKey) (and $syncerCert $syncerKey)}}
  certificates:
    {{- if and $tlsCert $tlsKey }}
    proxyCertificateSecretName: proxy-cert-secret
    {{- end }}
    {{- if and $syncerCert $syncerKey }}
    syncerCertificateSecretName: syncer-cert-secret
    {{- end }}
  {{- else if or $tlsSecret $syncerSecret }}
  certificates:
    {{- if $tlsSecret }}
    proxyCertificateSecretName: {{ .Values.tls.secret }}
    {{- end }}
    {{- if $syncerSecret }}
    syncerCertificateSecretName: {{ .Values.syncer.secret }}
    {{- end }}
  {{- end }}
  {{- if and .Values.ingress.enabled .Values.dns.domain }}
  ingressOrRouteSpec:
    apiFqdnUrl: "api-{{ .Values.name }}.{{ .Values.dns.domain }}"
    dbFqdnSuffix: "-db-{{ .Values.name }}.{{ .Values.dns.domain }}"
    {{- if or (eq .Values.ingress.type "nginx") (eq .Values.ingress.type "haproxy") }}
    method: ingress
    {{- else if eq .Values.ingress.type "route" }}
    method: openShiftRoute
    {{- else }}
    method: istio
    {{- end }}
    {{- if eq .Values.ingress.type "haproxy" }}
    ingressAnnotations:
      kubernetes.io/ingress.class: haproxy
      ingress.kubernetes.io/ssl-passthrough: "true"
    {{- else if eq .Values.ingress.type "nginx" }}
    ingressAnnotations:
      kubernetes.io/ingress.class: nginx
      nginx.ingress.kubernetes.io/ssl-passthrough: "true"
      nginx.ingress.kubernetes.io/backend-protocol: HTTPS
    {{- end }}
  {{- end }}
  {{- if .Values.ingress.enabled }}
  uiServiceType: ClusterIP
  {{- else }}
  uiServiceType: LoadBalancer
  {{- end }}
  {{- if and (eq .Values.ingress.type "lb") .Values.dns.domain }}
  uiAnnotations:
    external-dns.alpha.kubernetes.io/hostname: "redis-ui.{{ .Values.dns.domain }}"
  {{- end }}
  servicesRiggerSpec:
    {{- if .Values.ingress.enabled }}
    databaseServiceType: 'cluster_ip,headless'
    {{- else }}
    databaseServiceType: 'load_balancer,cluster_ip'
    {{- end }}
    serviceNaming: bdb_name
  services:
    apiService:
      {{- if .Values.ingress.enabled }}
      type: ClusterIP
      {{- else }}
      type: LoadBalancer
      {{- end }}
  {{- if .Values.license }}
  license: {{ .Values.license | quote }}
  {{- end }}
